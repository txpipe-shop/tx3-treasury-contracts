party Person;
party Vendor;
party TreasuryScript;
party VendorScript;

type Payout {
  maturation: Int,
  value: Map<Bytes, Map<Bytes, Int>>,
  paused: Bool,
}

type MultisigScript {
  key_hash: Bytes,
}

type VendorDatum {
  vendor: MultisigScript,
  payouts: List<Payout>,
}

type TreasuryRedeemer {
  Reorganize,
  SweepTreasury,
  Fund {
    amount: Map<Bytes, Map<Bytes, Int>>,
  },
  Disburse {
    amount: Map<Bytes, Map<Bytes, Int>>,
  },
}

type VendorRedeemer {
  Withdraw,
  Adjudicate {
    statuses: List<Bool>,
  },
  Modify,
  SweepVendor,
  Malformed,
}

// TREASURY OPERATIONS

// Yet to try
tx treasuryWithdraw(
  am: Int,
  registryUtxo: UtxoRef,
) {
  reference registry {
    ref: registryUtxo,
  }

  input current {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: Ada(am),
  }

  output person {
    to: Person,
    amount: current - fees,
  }

  cardano::withdrawal {
    from: TreasuryScript,
    amount: am,
    redeemer: (),
  }
}

tx treasuryFund(
  vendorKeyHash: Bytes,
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  collateralInput: UtxoRef,
  am: Int,
  mat: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    min_amount: Ada(am) + min_utxo(treasury),
    redeemer: TreasuryRedeemer::Fund {
      amount: { "": { "": am,},},
    },
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: VendorScript,
    // If AnyAsset works to represent ADA we could generalize every operation
    amount: Ada(am),
    datum: VendorDatum {
      vendor: MultisigScript {
        key_hash: vendorKeyHash,
      },
      payouts: [ Payout {
        maturation: mat,
        value: { "": { "": am,},},
        paused: false,
      }],
    },
  }

  output treasury {
    to: TreasuryScript,
    amount: current - Ada(am),
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}

// Simple example, only fragmenting into 2 outputs
tx treasuryFragment(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  treasuryInput: UtxoRef,
  am1: Int,
  am2: Int,
  collateralInput: UtxoRef,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    ref: treasuryInput,
    min_amount: Ada(am1 + am2),
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output treasury1 {
    to: TreasuryScript,
    amount: Ada(am1),
  }

  output treasury2 {
    to: TreasuryScript,
    amount: Ada(am2),
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}


// Simple example, only merging 2 outputs
tx treasuryMerge(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  treasuryInput1: UtxoRef,
  treasuryInput2: UtxoRef,
  collateralInput: UtxoRef,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current1 {
    from: TreasuryScript,
    ref: treasuryInput1,
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input current2 {
    from: TreasuryScript,
    ref: treasuryInput2,
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: current1 + current2,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}

tx treasuryDisburse(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  collateralInput: UtxoRef,
  outputAddress: Bytes,
  am: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    min_amount: Ada(am) + min_utxo(treasury),
    redeemer: TreasuryRedeemer::Disburse {
      amount: { "": { "": am, },},
    },
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: outputAddress,
    amount: Ada(am),
  }

  output treasury {
    to: TreasuryScript,
    amount: current - Ada(am),
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}


// This operation considers that only adas are in the treasury
tx treasurySweep(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  treasuryInput: UtxoRef,
  collateralInput: UtxoRef,
  sweepAmount: Int,
  since: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasury {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    ref: treasuryInput,
    redeemer: TreasuryRedeemer::SweepTreasury {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  cardano::treasury_donation {
    // Ideally this shouldnt be a parameter, but obtained resolving the input
    coin: sweepAmount,
  }

  collateral {
    ref: collateralInput,
  }

  validity {
    since_slot: since,
  }
}

// VENDOR OPERATIONS

tx vendorWithdraw(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  collateralInput: UtxoRef,
  since: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    redeemer: VendorRedeemer::Withdraw {},
    datum_is: VendorDatum,
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output vendor {
    to: Vendor,
    amount: current,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }


  collateral {
    ref: collateralInput,
  }

  signers {
    Vendor,
  }

  validity {
    since_slot: since,
  }
}


tx vendorAdjudicate(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  collateralInput: UtxoRef,
  since: Int,
  until: Int,
  pausedInput: Bool,
  maturationDatum: Int,
  amountDatum: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    redeemer: VendorRedeemer::Adjudicate {
      statuses: [ pausedInput, ],
    },
    datum_is: VendorDatum,
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: VendorScript,
    amount: current,
    datum: VendorDatum {
      vendor: current.vendor,
      payouts: [ Payout {
        // If we can access the datum, we could use something like
        // current.payouts.0.maturation and current.payouts.0.value
        maturation: maturationDatum,
        value: { "": { "": amountDatum, },},
        paused: pausedInput,
      }],
    },
  }

  output person {
    to: Person,
    amount: owner - fees,
  }


  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }


  validity {
    since_slot: since,
    until_slot: until,
  }
}

tx vendorSweep(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  collateralInput: UtxoRef,
  since: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    redeemer: VendorRedeemer::SweepVendor {},
    datum_is: VendorDatum,
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: current,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }


  collateral {
    ref: collateralInput,
  }

  validity {
    since_slot: since,
    until_slot: until,
  }
}

tx vendorMalformed(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  collateralInput: UtxoRef,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    redeemer: VendorRedeemer::Malformed {},
    datum_is: VendorDatum,
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: current,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }


  collateral {
    ref: collateralInput,
  }
}