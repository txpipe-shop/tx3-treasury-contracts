party Person;
party Vendor;
party TreasuryScript;
party VendorScript;

type Payout {
  maturation: Int,
  value: Map<Bytes, Map<Bytes, Int>>,
  paused: Bool,
}

type MultisigScript {
  key_hash: Bytes,
}

type VendorDatum {
  vendor: MultisigScript,
  payouts: List<Payout>,
}

type TreasuryRedeemer {
  Reorganize,
  SweepTreasury,
  Fund {
    amount: Map<Bytes, Map<Bytes, Int>>,
  },
  Disburse {
    amount: Map<Bytes, Map<Bytes, Int>>,
  },
}

type VendorRedeemer {
  Withdraw,
  Adjudicate {
    statuses: List<Bool>,
  },
  Modify,
  SweepVendor,
  Malformed,
}

// TREASURY OPERATIONS

// Yet to try
tx treasuryWithdraw(
  am: Int,
  registryUtxo: UtxoRef,
) {
  reference registry {
    ref: registryUtxo,
  }

  input current {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: Ada(am),
  }

  output person {
    to: Person,
    amount: current - fees,
  }

  cardano::withdrawal {
    from: TreasuryScript,
    amount: am,
    redeemer: (),
  }
}


// Only one payout can be added, and the payout only has one type of token involved
tx treasuryFund(
  vendorKeyHash: Bytes,
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  collateralInput: UtxoRef,
  policyInput: Bytes,
  tokenName: Bytes,
  am: Int,
  mat: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    min_amount: AnyAsset(policyInput, tokenName, am) ,
    redeemer: TreasuryRedeemer::Fund {
      amount: { policyInput: { tokenName: am,},},
    },
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees + min_utxo(treasury) + min_utxo(vendor),
  }

  output vendor {
    to: VendorScript,
    amount: AnyAsset(policyInput, tokenName, am) + min_utxo(vendor),
    datum: VendorDatum {
      vendor: MultisigScript {
        key_hash: vendorKeyHash,
      },
      payouts: [ Payout {
        maturation: mat,
        value: { policyInput: { tokenName: am,},},
        paused: false,
      }],
    },
  }

  output treasury {
    to: TreasuryScript,
    amount: current - AnyAsset(policyInput, tokenName, am) + min_utxo(treasury),
  }

  output person {
    to: Person,
    amount: owner - fees - min_utxo(treasury) - min_utxo(vendor),
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}

// Simple example, only fragmenting into 2 outputs
tx treasuryFragment(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  treasuryInput: UtxoRef,
  am: Int,
  policyInput: Bytes,
  tokenName: Bytes,
  collateralInput: UtxoRef,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    ref: treasuryInput,
    min_amount: AnyAsset(policyInput, tokenName, am),
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees + min_utxo(treasury1) + min_utxo(treasury2),
  }

  output treasury1 {
    to: TreasuryScript,
    amount: AnyAsset(policyInput, tokenName, am) + min_utxo(treasury1),
  }

  output treasury2 {
    to: TreasuryScript,
    amount: current - AnyAsset(policyInput, tokenName, am) + min_utxo(treasury2),
  }

  output person {
    to: Person,
    amount: owner - fees - min_utxo(treasury1) - min_utxo(treasury2),
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}


// Simple example, only merging 2 outputs
tx treasuryMerge(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  treasuryInput1: UtxoRef,
  treasuryInput2: UtxoRef,
  collateralInput: UtxoRef,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current1 {
    from: TreasuryScript,
    ref: treasuryInput1,
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input current2 {
    from: TreasuryScript,
    ref: treasuryInput2,
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: current1 + current2,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}

tx treasuryDisburse(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  collateralInput: UtxoRef,
  outputAddress: Bytes,
  policyInput: Bytes,
  tokenName: Bytes,
  am: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    min_amount: AnyAsset(policyInput, tokenName, am),
    redeemer: TreasuryRedeemer::Disburse {
      amount: { policyInput: { tokenName: am, },},
    },
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees + min_utxo(out)  + min_utxo(treasury),
  }

  output out {
    to: outputAddress,
    amount: AnyAsset(policyInput, tokenName, am) + min_utxo(out),
  }

  output treasury {
    to: TreasuryScript,
    amount: current - AnyAsset(policyInput, tokenName, am),
  }

  output person {
    to: Person,
    amount: owner - fees - min_utxo(out),
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}

tx treasurySweep(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  treasuryInput: UtxoRef,
  collateralInput: UtxoRef,
  sweepAmount: Int,
  since: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasury {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    ref: treasuryInput,
    redeemer: TreasuryRedeemer::SweepTreasury {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees + min_utxo(treasury),
  }

  output treasury {
    to: TreasuryScript,
    amount: current - Ada(sweepAmount) + min_utxo(treasury),
  }

  output person {
    to: Person,
    amount: owner - fees - min_utxo(treasury),
  }

  cardano::treasury_donation {
    // Ideally this shouldnt be a parameter, but obtained resolving the input
    coin: sweepAmount,
  }

  collateral {
    ref: collateralInput,
  }

  validity {
    since_slot: since,
  }
}

// VENDOR OPERATIONS

tx vendorWithdraw(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  collateralInput: UtxoRef,
  since: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    redeemer: VendorRedeemer::Withdraw {},
    datum_is: VendorDatum,
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output vendor {
    to: Vendor,
    amount: current,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }


  collateral {
    ref: collateralInput,
  }

  signers {
    Vendor,
  }

  validity {
    since_slot: since,
  }
}


tx vendorAdjudicate(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  collateralInput: UtxoRef,
  since: Int,
  until: Int,
  pausedInput: Bool,
  maturationDatum: Int,
  policyDatum: Bytes,
  nameDatum: Bytes,
  amountDatum: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    redeemer: VendorRedeemer::Adjudicate {
      statuses: [ pausedInput, ],
    },
    datum_is: VendorDatum,
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: VendorScript,
    amount: current,
    datum: VendorDatum {
      vendor: current.vendor,
      payouts: [ Payout {
        // If we can access the datum, we could use something like
        // current.payouts.0.maturation and current.payouts.0.value
        maturation: maturationDatum,
        value: { policyDatum: { nameDatum: amountDatum, },},
        paused: pausedInput,
      }],
    },
  }

  output person {
    to: Person,
    amount: owner - fees,
  }


  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }


  validity {
    since_slot: since,
    until_slot: until,
  }
}

// This operation only returns to the treasury a certain amount of a specific token from the vendor utxo
tx vendorModify(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  am: Int,
  // These parameters could be erased if
  // access to datum information of list type is possible
  policyInput: Bytes,
  tokenName: Bytes,
  pausedDatum: Bool,
  maturationDatum: Int,
  remainingAmount: Int,
  collateralInput: UtxoRef,
  since: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    min_amount: AnyAsset(policyInput, tokenName, am),
    redeemer: VendorRedeemer::Modify {},
    datum_is: VendorDatum,
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees + min_utxo(treasury ),
  }

  output {
    to: VendorScript,
    amount: current - AnyAsset(policyInput, tokenName, am),
    datum: VendorDatum {
      vendor: current.vendor,
      payouts: [ Payout {
        maturation: maturationDatum,
        // Remaining amount = current - AnyAsset(policyInput, tokenName, am)
        value: { policyInput: { tokenName: remainingAmount, },},
        paused: pausedDatum,
      }],
    },
  }


  output treasury {
    to: TreasuryScript,
    amount: AnyAsset(policyInput, tokenName, am) + min_utxo(treasury),
  }


  output person {
    to: Person,
    amount: owner - fees - min_utxo(treasury),
  }


  collateral {
    ref: collateralInput,
  }

  signers {
    Vendor,
    // We should be able to add Person as a signer
  }

  validity {
    since_slot: since,
    until_slot: until,
  }
}

tx vendorSweep(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  collateralInput: UtxoRef,
  since: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    redeemer: VendorRedeemer::SweepVendor {},
    datum_is: VendorDatum,
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: current,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }


  collateral {
    ref: collateralInput,
  }

  validity {
    since_slot: since,
    until_slot: until,
  }
}

tx vendorMalformed(
  registryRef: UtxoRef,
  vendorRef: UtxoRef,
  vendorUtxo: UtxoRef,
  collateralInput: UtxoRef,
) {
  reference registry {
    ref: registryRef,
  }

  reference vendorRef {
    ref: vendorRef,
  }

  input current {
    from: VendorScript,
    ref: vendorUtxo,
    redeemer: VendorRedeemer::Malformed {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: current,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }


  collateral {
    ref: collateralInput,
  }
}