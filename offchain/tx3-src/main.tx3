party Person;
party TreasuryScript;
party VendorScript;

type Status {
    Active,
    Paused,
}

type Payout {
  maturation: Int,
  value: Map<Bytes, Map<Bytes, Int>>,
  status: Status,
}

type MultisigScript {
  key_hash: Bytes,
}

type VendorDatum {
  vendor: MultisigScript,
  payouts: List<Payout>,
}

type TreasuryRedeemer {
  Reorganize,
  SweepTreasury,
  Fund {
    amount: Map<Bytes, Map<Bytes, Int>>,
  },
  Disburse {
    amount: Map<Bytes, Map<Bytes, Int>>,
  },
}

// Yet to try
tx treasuryWithdraw(
  am: Int,
  registryUtxo: UtxoRef,
) {
  reference registry {
    ref: registryUtxo,
  }

  input current {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: Ada(am),
  }

  output person {
    to: Person,
    amount: current - fees,
  }

  cardano::withdrawal {
    from: TreasuryScript,
    amount: am,
    redeemer: (),
  }
}

tx treasuryFund(
  vendorKeyHash: Bytes,
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  collateralInput: UtxoRef,
  am: Int,
  mat: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    min_amount: Ada(am) + min_utxo(treasury),
    redeemer: TreasuryRedeemer::Fund {
      amount: { "": { "": am,},},
    },
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: VendorScript,
    amount: Ada(am),
    datum: VendorDatum {
      vendor: MultisigScript {
        key_hash: vendorKeyHash,
      },
      payouts: [ Payout {
        maturation: mat,
        value: { "": { "": am,},},
        status: Status::Active {},
      }],
    },
  }

  output treasury {
    to: TreasuryScript,
    amount: current - Ada(am),
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}

// Simple example, only fragmenting into 2 outputs
tx treasuryFragment(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  treasuryInput: UtxoRef,
  am1: Int,
  am2: Int,
  collateralInput: UtxoRef,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    ref: treasuryInput,
    min_amount: Ada(am1 + am2),
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output treasury1 {
    to: TreasuryScript,
    amount: Ada(am1),
  }

  output treasury2 {
    to: TreasuryScript,
    amount: Ada(am2),
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}


// Simple example, only merging 2 outputs
tx treasuryMerge(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  treasuryInput1: UtxoRef,
  treasuryInput2: UtxoRef,
  collateralInput: UtxoRef,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current1 {
    from: TreasuryScript,
    ref: treasuryInput1,
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input current2 {
    from: TreasuryScript,
    ref: treasuryInput2,
    redeemer: TreasuryRedeemer::Reorganize {},
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: TreasuryScript,
    amount: current1 + current2,
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}

tx treasuryDisburse(
  registryRef: UtxoRef,
  treasuryRef: UtxoRef,
  collateralInput: UtxoRef,
  outputAddress: Bytes,
  am: Int,
  until: Int,
) {
  reference registry {
    ref: registryRef,
  }

  reference treasuryRef {
    ref: treasuryRef,
  }

  input current {
    from: TreasuryScript,
    min_amount: Ada(am) + min_utxo(treasury),
    redeemer: TreasuryRedeemer::Disburse {
      amount: { "": { "": am, },},
    },
  }

  input owner {
    from: Person,
    min_amount: min_utxo(person) + fees,
  }

  output {
    to: outputAddress,
    amount: Ada(am),
  }

  output treasury {
    to: TreasuryScript,
    amount: current - Ada(am),
  }

  output person {
    to: Person,
    amount: owner - fees,
  }

  collateral {
    ref: collateralInput,
  }

  signers {
    Person,
  }

  validity {
    until_slot: until,
  }
}
